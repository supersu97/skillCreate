---
name: "fullstack-development-helper"
description: "全栈开发助手，支持前端和后端项目开发。需要输入前端项目位置、后端项目位置，然后收集开发需求进行全栈开发。当需要进行全栈功能开发、前后端联调或同时修改前端后端代码时调用。"
---

# 全栈开发助手

*本技能专为Claude Code设计，帮助开发者同时处理前端和后端项目的开发任务。*

## 功能介绍

这个技能让开发者能够：

1. **前端代码开发**：支持Vue、React、Angular等主流前端框架
2. **后端代码开发**：支持Spring Boot、Django、Express等主流后端框架
3. **前后端联调**：协调前后端接口，确保数据交互正常
4. **需求分析**：分析全栈功能需求，生成开发方案
5. **代码生成**：根据需求同时生成前端和后端代码
6. **项目结构管理**：管理前端脚手架项目和后端项目的关系

## 何时调用

当你遇到以下情况时，应该调用这个技能：

- 需要开发一个涉及前端和后端的完整功能
- 需要同时修改前端和后端代码
- 前后端接口联调出现问题
- 不清楚前端项目或后端项目的文件位置
- 需要新建全栈功能模块
- 需要了解现有项目的技术栈和结构

## 执行指令（CRITICAL - 必须遵循）

### 步骤0：（新流程第一步）选择修改范围

**必须使用交互式选择**，首先让用户选择要修改的范围：

```javascript
{
  "questions": [{
    "question": "请选择要修改的范围：",
    "header": "修改范围",
    "multiSelect": false,
    "options": [
      {
        "label": "只修改前端代码",
        "description": "仅修改前端代码，不涉及后端修改"
      },
      {
        "label": "只修改后端代码",
        "description": "仅修改后端代码，不涉及前端修改"
      },
      {
        "label": "同时修改前后端代码",
        "description": "需要同时修改前端和后端代码"
      }
    ]
  }]
}
```

**记录用户的选择**，根据选择执行不同流程：
- 如果选择"只修改前端代码" → 跳过步骤0.2的后端项目收集，只收集前端项目路径
- 如果选择"只修改后端代码" → 跳过步骤0.2的前端项目收集，只收集后端项目路径
- 如果选择"同时修改前后端代码" → 收集前端和后端项目路径，后续进入协同开发模式选择

### 步骤0.1：收集项目位置信息

**根据步骤0的选择，只收集需要的项目位置**

#### 0.1.1 如果只修改前端（只需收集前端项目路径）

**必须使用交互式选择**，执行以下流程：

```javascript
{
  "questions": [{
    "question": "请选择前端项目位置输入方式：",
    "header": "输入方式",
    "multiSelect": false,
    "options": [
      {
        "label": "手动输入路径",
        "description": "直接输入前端项目的文件夹路径"
      },
      {
        "label": "自动检测",
        "description": "在当前目录或指定目录下自动查找前端项目"
      }
    ]
  }]
}
```

**情况A：手动输入路径**
```
请输入前端项目文件夹路径（例如：./my-vue-project 或 D:/projects/frontend）：
```

**情况B：自动检测**
```
请输入要检测的根目录（直接回车表示当前目录）：
```

然后使用 Glob 工具自动查找项目：
```javascript
调用 Glob 工具：
- path: [用户指定的目录]
- pattern: "**/package.json"
```

#### 0.1.2 如果只修改后端（只需收集后端项目路径）

**必须使用交互式选择**，执行以下流程：

```javascript
{
  "questions": [{
    "question": "请选择后端项目位置输入方式：",
    "header": "输入方式",
    "multiSelect": false,
    "options": [
      {
        "label": "手动输入路径",
        "description": "直接输入后端项目的文件夹路径"
      },
      {
        "label": "自动检测",
        "description": "在当前目录或指定目录下自动查找后端项目"
      }
    ]
  }]
}
```

**情况A：手动输入路径**
```
请输入后端项目文件夹路径（例如：./my-spring-boot 或 D:/projects/backend）：
```

**情况B：自动检测**
```
请输入要检测的根目录（直接回车表示当前目录）：
```

然后使用 Glob 工具自动查找项目：
```javascript
调用 Glob 工具：
- path: [用户指定的目录]
- pattern: "**/pom.xml"

调用 Glob 工具：
- path: [用户指定的目录]
- pattern: "**/build.gradle"

调用 Glob 工具：
- path: [用户指定的目录]
- pattern: "**/requirements.txt"
```

#### 0.1.3 如果同时修改前后端（需要收集两个项目路径）

**必须使用交互式选择**，执行以下流程：

```javascript
{
  "questions": [{
    "question": "请选择项目位置输入方式：",
    "header": "输入方式",
    "multiSelect": false,
    "options": [
      {
        "label": "手动输入路径",
        "description": "直接输入前端和后端项目的文件夹路径"
      },
      {
        "label": "自动检测",
        "description": "在当前目录或指定目录下自动查找前端和后端项目"
      },
      {
        "label": "使用脚手架目录",
        "description": "前端在脚手架文件夹内，后端在外部或其他位置"
      }
    ]
  }]
}
```

**情况A：手动输入路径**

1. 询问前端项目位置：
   ```
   请输入前端项目文件夹路径（例如：./my-vue-project 或 D:/projects/frontend）：
   ```

2. 询问后端项目位置：
   ```
   请输入后端项目文件夹路径（例如：./my-spring-boot 或 D:/projects/backend）：
   ```

**情况B：自动检测**

1. 询问要在哪个目录检测：
   ```
   请输入要检测的根目录（直接回车表示当前目录）：
   ```

2. 使用 Glob 工具自动查找项目：
   ```javascript
   // 查找前端项目特征文件
   调用 Glob 工具：
   - path: [用户指定的目录]
   - pattern: "**/package.json"
   
   调用 Glob 工具：
   - path: [用户指定的目录]
   - pattern: "**/vue.config.js"
   
   // 查找后端项目特征文件
   调用 Glob 工具：
   - path: [用户指定的目录]
   - pattern: "**/pom.xml"
   
   调用 Glob 工具：
   - path: [用户指定的目录]
   - pattern: "**/build.gradle"
   
   调用 Glob 工具：
   - path: [用户指定的目录]
   - pattern: "**/requirements.txt"
   ```

3. 分析检测结果，确定项目类型和位置

**情况C：使用脚手架目录**

1. 询问脚手架根目录：
   ```
   请输入脚手架项目的根目录（例如：./scaffold 或 D:/projects/scaffold）：
   ```

2. 询问前端项目在脚手架中的位置：
   ```
   请输入前端项目在脚手架中的相对路径（例如：client、frontend、app）：
   ```

3. 询问后端项目位置：
   ```
   请输入后端项目位置：
   1. 在脚手架内的相对路径（例如：server、backend）
   2. 在脚手架外部的绝对路径或相对路径
   ```

4. 使用 Glob/Read 工具验证项目结构：
   ```javascript
   // 验证前端项目
   调用 Glob 工具：
   - path: [脚手架目录]/[前端相对路径]
   - pattern: "package.json"
   
   // 验证后端项目
   调用 Glob 工具：
   - path: [后端目录]
   - pattern: "pom.xml" 或 "build.gradle" 或 "requirements.txt"
   ```

#### 0.1.4 确认项目位置

根据选择的修改范围显示检测到的项目：

**只修改前端时**：
```
检测到以下前端项目：
- 前端项目：[前端路径]
  技术栈：[Vue/React/Angular + 具体框架版本]
  入口文件：[package.json路径]

请确认项目位置是否正确？
```

**只修改后端时**：
```
检测到以下后端项目：
- 后端项目：[后端路径]
  技术栈：[Spring Boot/Django/Express + 具体框架版本]
  入口文件：[pom.xml/build.gradle路径]

请确认项目位置是否正确？
```

**同时修改前后端时**：
```
检测到以下项目：
- 前端项目：[前端路径]
  技术栈：[Vue/React/Angular + 具体框架版本]
  入口文件：[package.json路径]
  
- 后端项目：[后端路径]
  技术栈：[Spring Boot/Django/Express + 具体框架版本]
  入口文件：[pom.xml/build.gradle路径]

请确认项目位置是否正确？
```

### 步骤1：分析项目结构

根据收集到的项目路径，使用 Glob 和 Read 工具分析项目结构：

```javascript
// 分析前端项目结构（如果需要修改前端）
调用 Glob 工具：
- path: [前端项目路径]
- pattern: "src/**/*"

调用 Read 工具：
- file_path: [前端项目路径]/package.json

// 分析后端项目结构（如果需要修改后端）
调用 Glob 工具：
- path: [后端项目路径]
- pattern: "src/**/*"

调用 Read 工具：
- file_path: [后端路径]/pom.xml 或 build.gradle 或 requirements.txt
```

生成项目结构报告：
```
## 项目结构分析

### 前端项目
- 框架：[Vue 3 / React 18 / Angular 16]
- UI组件库：[Element Plus / Ant Design / Material UI]
- 状态管理：[Pinia / Redux / NgRx]
- 路由：[Vue Router / React Router]
- API调用方式：[Axios / Fetch / 自定义]
- 目录结构：
  - src/api：接口定义
  - src/components：组件
  - src/views：页面
  - src/store：状态管理
  - src/router：路由配置

### 后端项目
- 框架：[Spring Boot 3.x / Django 4.x / Express]
- 数据库：[MySQL / PostgreSQL / MongoDB]
- ORM：[JPA / Hibernate / Sequelize / Prisma]
- 认证：[JWT / Session / OAuth]
- 目录结构：
  - src/main/java/...：Java源码
  - src/main/resources：配置文件
  - src/test：测试代码
```

### 步骤1.5：（关键）分析代码风格

**必须分析现有代码风格，生成代码风格指南，后续所有代码生成必须严格遵循**

根据选择的修改范围分析代码风格：

**如果修改前端**：
```javascript
调用 Glob 工具：
- path: [前端项目路径]/src
- pattern: "**/*.vue" 或 "**/*.tsx" 或 "**/*.jsx"

调用 Glob 工具：
- path: [前端项目路径]/src
- pattern: "**/*.css" 或 "**/*.scss" 或 "**/*.less"

调用 Glob 工具：
- path: [前端项目路径]/src
- pattern: "**/api/**/*.js" 或 "**/api/**/*.ts"

调用 Read 工具读取3-5个代表性文件：
- 组件文件（如：src/components 下的 .vue/.tsx 文件）
- API服务文件（如：src/api 下的服务文件）
- 样式文件（如：src/styles 或组件内的样式）
```

**如果修改后端**：
```javascript
调用 Glob 工具：
- path: [后端项目路径]/src
- pattern: "**/*.java" 或 "**/*.py" 或 "**/*.js"

调用 Read 工具读取3-5个代表性文件：
- Controller/Handler文件
- Service业务逻辑文件
- Model/Entity实体文件
- 数据库操作文件（如：Mapper/DAO/Repository）
```

生成代码风格指南：
```
## 代码风格指南（必须严格遵循）

### 前端代码风格

#### 1. 组件风格
- 文件命名：[如：UserList.vue、UserDetail.jsx]
- 组件命名：[如：UserList、UserDetailComponent]
- Props定义：[如：defineProps、PropTypes]
- 状态管理：[如：ref/reactive、useState]

#### 2. API调用风格
- 请求方式：[如：axios.get/post、fetch]
- 参数传递：[如：params/、data/、body]
- 错误处理：[如：.catch、try-catch]
- 类型定义：[如：TypeScript接口、Flow类型]

#### 3. 样式风格
- 样式方案：[如：CSS Modules、SCSS、Styled Components]
- 类名命名：[如：BEM命名、语义化命名]
- 响应式：[如：媒体查询、弹性盒、栅格]
- 组件样式：[如： scoped样式、 CSS-in-JS]
```

### 后端代码风格

#### 1. 命名风格
- 类命名：[如：UserController、UserService]
- 方法命名：[如：getUserById、createUser]
- 变量命名：[如：userId、userList]
- 常量命名：[如：USER_STATUS、MAX_COUNT]

#### 2. 代码结构风格
- 分层结构：[如：Controller → Service → Mapper]
- 参数校验：[如：@Valid、@NotNull]
- 事务管理：[如：@Transactional]
- 异常处理：[如：@ExceptionHandler、try-catch]

#### 3. 数据库操作风格
- 查询方式：[如：JPQL、@Query、XML映射]
- 命名规范：[如：下划线命名、驼峰命名]
- 关联关系：[如：@OneToMany、@ManyToOne]

**重要提示**：后续所有生成的代码必须严格遵循上述代码风格，禁止使用与现有代码风格不一致的实现方式。同时，必须严格遵循用户指定的修改范围，没有要求改动的地方必须保持原样，不得进行额外修改。

### 步骤2：收集开发需求

使用 AskUserQuestion 工具选择需求类型和接口文档输入：

**根据步骤0的选择显示不同的选项**：

**只修改前端时**：
```javascript
{
  "questions": [
    {
      "question": "请选择前端开发需求类型：",
      "header": "需求类型",
      "multiSelect": false,
      "options": [
        {
          "label": "新增功能",
          "description": "开发一个全新的前端功能"
        },
        {
          "label": "修改功能",
          "description": "修改现有的前端功能"
        },
        {
          "label": "接口对接",
          "description": "对接后端接口，更新前端API调用"
        },
        {
          "label": "性能优化",
          "description": "优化前端性能"
        },
        {
          "label": "Bug修复",
          "description": "修复前端Bug"
        },
        {
          "label": "代码审查",
          "description": "审查前端代码质量"
        }
      ]
    }
  ]
}
```

**只修改后端时**：
```javascript
{
  "questions": [
    {
      "question": "请选择后端开发需求类型：",
      "header": "需求类型",
      "multiSelect": false,
      "options": [
        {
          "label": "新增功能",
          "description": "开发一个全新的后端功能"
        },
        {
          "label": "修改功能",
          "description": "修改现有的后端功能"
        },
        {
          "label": "接口调整",
          "description": "调整现有接口的参数或响应"
        },
        {
          "label": "性能优化",
          "description": "优化后端性能"
        },
        {
          "label": "Bug修复",
          "description": "修复后端Bug"
        },
        {
          "label": "代码审查",
          "description": "审查后端代码质量"
        }
      ]
    },
    {
      "question": "请选择接口文档输入方式（可选）：",
      "header": "接口文档",
      "multiSelect": false,
      "options": [
        {
          "label": "本地文件",
          "description": "提供本地接口文档文件路径（支持YAML/JSON/Markdown/Postman）"
        },
        {
          "label": "在线链接",
          "description": "提供在线接口文档URL（支持Swagger/OpenAPI/Markdown）"
        },
        {
          "label": "暂无接口文档",
          "description": "暂无接口文档，需要根据需求自行设计接口"
        }
      ]
    }
  ]
}
```

**同时修改前后端时**：
```javascript
{
  "questions": [
    {
      "question": "请选择开发需求类型：",
      "header": "需求类型",
      "multiSelect": false,
      "options": [
        {
          "label": "新增功能",
          "description": "开发一个全新的前后端功能"
        },
        {
          "label": "修改功能",
          "description": "修改现有的前后端功能"
        },
        {
          "label": "接口联调",
          "description": "解决前后端接口对接问题"
        },
        {
          "label": "性能优化",
          "description": "优化前后端性能"
        },
        {
          "label": "Bug修复",
          "description": "修复前后端的Bug"
        },
        {
          "label": "代码审查",
          "description": "审查前后端代码质量"
        }
      ]
    }
  ]
}
```

**注意**：如果需要后端对接第三方接口文档，将在后续的协同开发模式中收集。

**收集详细需求**：

**只修改前端时**：
```
请详细描述要修改的前端内容：
1. 功能名称：
2. 功能描述：
3. 前端需求：
   - 页面/组件：
   - 用户交互：
   - 数据展示：
4. 接口信息（如果有）：
   - 接口路径：
   - 请求方式：
   - 请求参数：
   - 响应格式：
```

**只修改后端时**：
```
请详细描述要修改的后端内容：
1. 功能名称：
2. 功能描述：
3. 后端需求：
   - API接口：
   - 业务逻辑：
   - 数据存储：
   - 数据库变更（如有）：是否涉及数据库表结构修改？如涉及，将生成相应SQL语句供执行
4. 接口设计（如无接口文档）：
   - 请求格式：
   - 响应格式：
```

**同时修改前后端时**：
```
请详细描述要开发的新功能或修改内容：
1. 功能名称：
2. 功能描述：
3. 前端需求：
   - 页面/组件：
   - 用户交互：
   - 数据展示：
4. 后端需求：
   - API接口：
   - 业务逻辑：
   - 数据存储：
   - 数据库变更（如有）：是否涉及数据库表结构修改？如涉及，将生成相应SQL语句供执行
5. 接口文档（可选）：
   - 如有接口文档，请选择输入方式：
     ① 本地文件路径（例如：./docs/api.yaml 或 D:/api-docs/openapi.json）
     ② 在线文档链接（例如：https://api.example.com/docs 或 Swagger URL）
     ③ 暂无接口文档，需要根据需求自行设计
6. 接口设计（如无接口文档）：
   - 请求格式：
   - 响应格式：
```

### 步骤3：确认修改内容

**在执行代码修改之前，必须先确认要修改的具体内容**

根据步骤0的选择，收集并确认修改内容：

**只修改前端时**：
```
请确认要修改的前端内容：

1. 修改范围：
   - 需要修改的页面/组件：
   - 需要修改的文件：
   
2. 修改要求：
   - 要实现什么功能/修复什么问题：
   - 期望的效果：
   
3. 接口信息（如有）：
   - 涉及的接口路径：
   - 接口变更说明：
```

**只修改后端时**：
```
请确认要修改的后端内容：

1. 修改范围：
   - 需要修改的API接口：
   - 需要修改的类/方法：
   
2. 修改要求：
   - 要实现什么功能/修复什么问题：
   - 期望的效果：
   
3. 数据库变更（如有）：
   - 是否需要修改表结构：
   - 变更说明：
```

**同时修改前后端时**：
```
请确认要修改的完整内容：

1. 功能概述：
   - 要实现什么功能/修复什么问题：
   
2. 前端修改范围：
   - 需要修改的页面/组件：
   - 需要修改的文件：
   
3. 后端修改范围：
   - 需要修改的API接口：
   - 需要修改的类/方法：
   
4. 接口变更：
   - 是否有接口变化：
   - 变化说明：
   
5. 数据库变更（如有）：
   - 是否需要修改表结构：
   - 变更说明：
```

**确认修改内容后**，根据步骤0的选择执行不同的流程。

### 步骤4：执行开发任务

**根据步骤0的选择执行不同的流程**

#### 4.1 只修改前端 → 选择前端修改方式 → 执行

直接进入"执行前端代码修改"流程（见下方步骤5）

#### 4.2 只修改后端 → 选择后端修改方式 → 执行

直接进入"执行后端代码修改"流程（见下方步骤6）

#### 4.3 同时修改前后端 → 选择协同开发模式

**必须使用交互式选择**，让用户选择协同开发模式：

```javascript
{
  "questions": [{
    "question": "请选择协同开发模式：",
    "header": "协同模式",
    "multiSelect": false,
    "options": [
      {
        "label": "后端先改模式",
        "description": "后端先修改，确定接口规范，前端再同步修改"
      },
      {
        "label": "Agent Team协作模式",
        "description": "创建前端和后端Agent团队，先收集完整需求，再并行执行修改"
      }
    ]
  }]
}
```

**根据选择的模式执行相应流程：**

**模式A：后端先改模式**

按照以下流程执行：

## 后端先改模式流程

### 第一步：收集后端修改需求
先收集后端的完整修改需求：

1. 功能需求：详细描述要实现的后端功能

2. **第三方接口文档（如需要对接第三方API）**：
使用 AskUserQuestion 工具询问：
```javascript
{
  "questions": [{
    "question": "后端是否需要对接第三方接口？",
    "header": "第三方接口",
    "multiSelect": false,
    "options": [
      {
        "label": "需要对接第三方接口",
        "description": "需要调用第三方API，需要提供第三方接口文档"
      },
      {
        "label": "不需要对接第三方接口",
        "description": "仅修改内部逻辑，不需要第三方接口"
      }
    ]
  }]
}
```

**如果选择"需要对接第三方接口"**：
```
请提供第三方接口文档：
- 支持格式：YAML (.yaml/.yml)、JSON (.json)、Markdown (.md)、Postman Collection (.json)
- 示例路径：
  • ./docs/third-party-api.yaml
  • https://api.third-party.com/docs
- 如需认证，请提供认证信息：
```

**如果选择"不需要对接第三方接口"**：
```
好的，将根据需求自行设计后端接口。

3. 接口设计（如无第三方接口）：
   - 请求格式：
   - 响应格式：

4. 数据变更：如有数据库变更，提供SQL语句

5. 具体修改：明确后端需要修改的文件、类、方法

### 第二步：执行后端代码修改
基于收集的后端需求，执行"执行后端代码修改"流程。

### 第三步：确定接口规范
后端修改完成后，确定新的接口规范：
- 接口路径和方法
- 请求/响应格式
- 参数和返回值
- 错误处理机制

### 第四步：收集前端修改需求
基于后端确定的接口规范，收集前端修改需求：
1. 前端需要调用的接口
2. 需要修改的前端API服务调用
3. 需要更新的页面组件和数据处理
4. 具体的前端修改内容

### 第五步：执行前端代码修改
基于收集的前端需求，执行"执行前端代码修改"流程。

### 第六步：完成模式总结

```
## 后端先改模式完成

模式执行结果：
1. 后端修改：已完成后端代码修改和接口规范确定
2. 前端修改：已基于后端接口规范完成前端代码修改
3. 接口一致性：前后端基于同一接口规范实现

后端先改模式执行完毕。
```

**模式B：Agent Team协作模式**

按照以下流程执行：

**第一步：收集完整修改需求（需求先行）**
在执行任何修改之前，先收集完整的前端和后端修改需求。

**1.1 收集前端修改需求**

使用 AskUserQuestion 工具让用户选择前端修改方式：
```javascript
{
  "questions": [{
    "question": "请选择前端修改方式：",
    "header": "前端修改",
    "multiSelect": false,
    "options": [
      {
        "label": "直接描述进行修改",
        "description": "直接描述要修改的内容和要求"
      },
      {
        "label": "根据后端接口进行修改",
        "description": "前端Agent将向后端Agent询问具体的接口信息，然后根据接口进行修改"
      },
      {
        "label": "根据接口文档进行修改",
        "description": "提供本地或在线接口文档，根据文档更新API调用"
      },
      {
        "label": "根据指定组件或文件进行修改",
        "description": "指定具体的组件、页面或文件，然后说明要修改的内容"
      },
      {
        "label": "直接新增组件或页面",
        "description": "添加新的组件、页面或功能模块"
      },
      {
        "label": "修复bug或样式问题",
        "description": "修复前端bug、样式问题或兼容性问题"
      },
      {
        "label": "优化性能或用户体验",
        "description": "优化前端性能、用户体验或进行代码重构"
      }
    ]
  }]
}
```

**如果选择"根据后端接口进行修改"**：
```
请确认是否需要前端Agent向后端Agent询问具体接口信息？
- 选择此项后，前端Agent将在执行时向后端Agent询问：
  • 接口路径和方法
  • 请求/响应格式
  • 参数和返回值
- 前端Agent会根据获取到的接口信息进行修改
```

根据用户选择的前端修改方式，收集详细的前端修改信息（参考步骤5的第一步和第二步）。

**1.2 收集后端修改需求**

使用 AskUserQuestion 工具让用户选择后端修改方式：
```javascript
{
  "questions": [{
    "question": "请选择后端修改方式：",
    "header": "后端修改",
    "multiSelect": false,
    "options": [
      {
        "label": "直接描述进行修改",
        "description": "直接描述要修改的内容和要求"
      },
      {
        "label": "根据接口路径进行修改",
        "description": "输入接口路径，自动查找并修改后端对应代码"
      },
      {
        "label": "根据接口文档进行修改",
        "description": "提供本地或在线接口文档，根据文档更新API实现"
      },
      {
        "label": "根据指定类或文件进行修改",
        "description": "指定具体的类、Service或文件，然后说明要修改的内容"
      },
      {
        "label": "直接新增API或功能",
        "description": "添加新的API接口或业务功能"
      },
      {
        "label": "修复bug或逻辑问题",
        "description": "修复后端bug、业务逻辑问题或异常处理"
      },
      {
        "label": "优化性能或数据库操作",
        "description": "优化后端性能、数据库查询或进行代码重构"
      }
    ]
  }]
}
```

根据用户选择的后端修改方式，收集详细的后端修改信息（参考步骤6的第一步和第二步）。

**1.3 收集数据库变更（如有）**
如果修改涉及数据库变更，询问：
```
请确认是否需要数据库变更？
- 如果需要，请描述需要的表结构变更：
- 或者提供SQL语句：
```

**1.4 生成完整修改需求汇总**

```
## 完整修改需求汇总

### 功能概述
[整体功能描述]

### 前端修改需求
- 修改方式：[选择的修改方式]
- 修改范围：[具体文件/组件]
- 修改内容：[详细描述]

### 后端修改需求
- 修改方式：[选择的修改方式]
- 修改范围：[具体类/方法]
- 修改内容：[详细描述]

### 数据库变更（如有）
[SQL语句或变更描述]

### 代码风格要求
- 前端代码风格：严格遵循步骤1.5中分析的前端代码风格
- 后端代码风格：严格遵循步骤1.5中分析的后端代码风格
```

请确认以上修改需求是否正确？

**第二步：生成完整修改方案文档**
基于收集的需求，生成完整的修改方案文档：

```
## 全栈修改方案文档

### 功能概述
[功能描述]

### 接口定义（如需要）
| 接口 | 方法 | 路径 | 请求参数 | 响应格式 |
|------|------|------|----------|----------|
| [接口名] | [方法] | [路径] | [参数] | [响应] |

### 前端修改清单
1. 文件：[文件路径]
   - 修改：[具体修改内容]
   - 要求：[实现要求]

2. 文件：[文件路径]
   - 修改：[具体修改内容]
   - 要求：[实现要求]

### 后端修改清单
1. 文件：[文件路径]
   - 修改：[具体修改内容]
   - 要求：[实现要求]

2. 文件：[文件路径]
   - 修改：[具体修改内容]
   - 要求：[实现要求]

### 数据库变更（如需要）
```sql
[SQL语句]
```

### 代码风格要求
- 严格遵循步骤1.5中分析的代码风格
- 修改范围限制：严格遵循用户指定的修改范围
```

**第三步：创建Agent Team并分配任务**
基于完整的修改方案文档，创建专业Agent团队：

```
## Agent Team创建完成

已成功创建以下Agent：
1. **接口协调Agent** - 基于方案文档协调前后端实现（如需要）
2. **后端开发Agent** - 基于方案文档执行后端修改
3. **前端开发Agent** - 基于方案文档执行前端修改

开始执行Agent并行修改...
```

**第四步：Agent并行执行修改**
所有Agent基于同一份修改方案文档并行执行：

- **后端开发Agent**：根据方案文档中的后端修改清单，执行"执行后端代码修改"流程
- **前端开发Agent**：根据方案文档中的前端修改清单，执行"执行前端代码修改"流程
  - **特别注意**：如果前端修改方式选择的是"根据后端接口进行修改"，则前端Agent需要：
    1. 等待后端Agent完成接口开发
    2. 向后端Agent询问具体的接口信息（接口路径、方法、请求/响应格式、参数返回值）
    3. 根据获取到的接口信息执行前端代码修改
- **接口协调Agent**：确保前后端实现与方案文档中的接口定义一致

**第五步：完成协作并总结**
```
## Agent Team协作完成

协作结果总结：
1. 需求收集：已完成完整需求收集和方案文档
2. 后端开发：已基于方案文档完成后端代码修改
3. 前端开发：已基于方案文档完成前端代码修改
4. 协调验证：已确保前后端实现一致性

所有Agent基于同一份方案文档完成修改，协作流程结束。
```

### 步骤5：执行前端代码修改

当需要执行前端代码修改时，必须按照以下流程执行：

**第一步：前端修改方式选择**
使用 AskUserQuestion 工具提供前端修改方式选择：
```javascript
{
  "questions": [{
    "question": "请选择前端修改方式：",
    "header": "前端修改",
    "multiSelect": false,
    "options": [
      {
        "label": "直接描述进行修改",
        "description": "直接描述要修改的内容和要求"
      },
      {
        "label": "根据后端接口路径进行修改",
        "description": "输入后端接口路径，自动查找并修改前端对应代码"
      },
      {
        "label": "根据接口文档进行修改",
        "description": "提供本地或在线接口文档，根据文档更新API调用"
      },
      {
        "label": "根据指定组件或文件进行修改",
        "description": "指定具体的组件、页面或文件，然后说明要修改的内容"
      },
      {
        "label": "直接新增组件或页面",
        "description": "添加新的组件、页面或功能模块"
      },
      {
        "label": "修复bug或样式问题",
        "description": "修复前端bug、样式问题或兼容性问题"
      },
      {
        "label": "优化性能或用户体验",
        "description": "优化前端性能、用户体验或进行代码重构"
      }
    ]
  }]
}
```

**第二步：根据选择收集前端修改信息**
- 如果选择"直接描述进行修改"，询问："请详细描述要修改的内容和要求："
- 如果选择"根据后端接口路径进行修改"：
  1. 首先询问："请提供需要修改的后端接口信息："
  2. 使用 Grep 工具在前端项目中查找接口调用
  3. 显示找到的对应前端代码
  4. 询问："请描述要如何修改这些代码："
- 如果选择"根据接口文档进行修改"：
  1. 询问接口文档位置（本地文件路径或在线链接）
  2. 读取并解析接口文档
  3. 查找需要修改的前端代码
  4. 询问："请描述要如何根据接口文档修改："
- 如果选择"根据指定组件或文件进行修改"：
  1. 询问具体的组件/文件路径或名称
  2. 使用 Glob 工具查找对应文件
  3. 读取文件内容
  4. 询问："请描述要修改的内容："
- 如果选择"直接新增组件或页面"：
  1. 询问新增的组件/页面名称和位置
  2. 询问功能描述
  3. 直接生成新代码
- 如果选择"修复bug或样式问题"：
  1. 询问问题描述或错误信息
  2. 定位问题代码
  3. 修复问题
- 如果选择"优化性能或用户体验"：
  1. 询问优化目标
  2. 分析现有代码
  3. 进行优化

**第三步：执行前端代码修改**

1. 使用 Grep/Glob 工具定位需要修改的文件
2. 使用 Read 工具读取文件内容
3. 使用 SearchReplace/Write 工具修改代码
4. 确认修改完成

**重要约束**：
- 必须严格遵循步骤1.5中分析的前端代码风格
- 严格遵循用户指定的修改范围，没有要求改动的地方必须保持原样

### 步骤6：执行后端代码修改

当需要执行后端代码修改时，必须按照以下流程执行：

**第一步：后端修改方式选择**
使用 AskUserQuestion 工具提供后端修改方式选择：
```javascript
{
  "questions": [{
    "question": "请选择后端修改方式：",
    "header": "后端修改",
    "multiSelect": false,
    "options": [
      {
        "label": "直接描述进行修改",
        "description": "直接描述要修改的内容和要求"
      },
      {
        "label": "根据接口路径进行修改",
        "description": "输入接口路径，自动查找并修改后端对应代码"
      },
      {
        "label": "根据接口文档进行修改",
        "description": "提供本地或在线接口文档，根据文档更新API实现"
      },
      {
        "label": "根据指定类或文件进行修改",
        "description": "指定具体的类、Service或文件，然后说明要修改的内容"
      },
      {
        "label": "直接新增API或功能",
        "description": "添加新的API接口或业务功能"
      },
      {
        "label": "修复bug或逻辑问题",
        "description": "修复后端bug、业务逻辑问题或异常处理"
      },
      {
        "label": "优化性能或数据库操作",
        "description": "优化后端性能、数据库查询或进行代码重构"
      }
    ]
  }]
}
```

**第二步：根据选择收集后端修改信息**
- 如果选择"直接描述进行修改"，询问："请详细描述要修改的内容和要求："
- 如果选择"根据接口路径进行修改"：
  1. 首先询问："请提供需要修改的接口路径："
  2. 使用 Grep 工具在后端项目中查找接口
  3. 显示找到的对应后端代码
  4. 询问："请描述要如何修改这些代码："
- 如果选择"根据接口文档进行修改"：
  1. 询问接口文档位置（本地文件路径或在线链接）
  2. 读取并解析接口文档
  3. 查找需要修改的后端代码
  4. 询问："请描述要如何根据接口文档修改："
- 如果选择"根据指定类或文件进行修改"：
  1. 询问具体的类/文件路径或名称
  2. 使用 Glob 工具查找对应文件
  3. 读取文件内容
  4. 询问："请描述要修改的内容："
- 如果选择"直接新增API或功能"：
  1. 询问新增的API路径和方法
  2. 询问功能描述
  3. 直接生成新代码
- 如果选择"修复bug或逻辑问题"：
  1. 询问问题描述或错误信息
  2. 定位问题代码
  3. 修复问题
- 如果选择"优化性能或数据库操作"：
  1. 询问优化目标
  2. 分析现有代码
  3. 进行优化

**第三步：执行后端代码修改**

1. 使用 Grep/Glob 工具定位需要修改的文件
2. 使用 Read 工具读取文件内容
3. 使用 SearchReplace/Write 工具修改代码
4. 确认修改完成

**重要约束**：
- 必须严格遵循步骤1.5中分析的后端代码风格
- 严格遵循用户指定的修改范围，没有要求改动的地方必须保持原样

### 接口文档处理流程（如有需要）

如果用户提供了接口文档，按照以下流程处理：

**情况A：本地文件**
```
1. 读取本地接口文档文件
   调用 Read 工具：
   - file_path: [用户提供的本地文件路径]
   
2. 解析文档格式
   - YAML文件：使用YAML解析器
   - JSON文件（OpenAPI/Swagger）：解析JSON结构
   - Markdown文件：提取接口定义
   - Postman集合：导入Collection格式
   
3. 提取接口信息
   - 接口路径和方法
   - 请求参数和类型
   - 响应结构和状态码
   - 认证要求
```

**情况B：在线文档链接**
```
1. 获取在线接口文档
   - 如果是公开URL：直接获取
   - 如果需要认证：提示用户提供认证信息
   
2. 解析文档格式
   - Swagger/OpenAPI 2.0/3.0：解析规范
   - Markdown文档：提取接口说明
   - HTML页面：解析接口表格

3. 验证接口可用性
   - 测试接口连通性
   - 检查接口响应格式
```

**情况C：暂无接口文档**
```
1. 根据需求设计接口
   - 分析前端需要的数据
   - 设计RESTful API结构
   - 确定请求/响应格式
   
2. 生成接口设计文档
   - 接口列表
   - 参数说明
   - 响应示例
   - 错误码定义
```
